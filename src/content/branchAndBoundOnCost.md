---
type: algorithm
solverKey: branchAndBoundOnCost
friendlyName: Branch and Bound on Cost
class: exhaustive
defaults:
  evaluatingDetailLevel: 2
  maxEvaluatingDetailLevel: 2
---


# Branch and Bound on Cost

This is a recursive algorithm, similar to depth first search, that is guarunteed to find the optimal solution.

The candidate solution space is generated by systematically traversing possible paths, and discarding large subsets of fruitless candidates by comparing the current solution to an upper and lower bound. In this case, the upper bound is the best path found so far.

While evaluating paths, if at any point the current solution is already more expensive (longer) than the best complete path discovered, there is no point continuing.

For example, imagine a solution ```A -> B -> C -> D -> E -> A``` was already found with a cost of 100.

If during our search, we are evaluating ```A -> C -> E```, which has a cost of 110, there is no point evaluating the remaining solutions.

Instead of continuing to evaluate all of the child solutions from here, we can go down a different path, eliminating candidates not worth evaluating:

```A -> C -> E -> D -> B -> A```

```A -> C -> E -> B -> D -> A```


## The code

```javascript
const branchAndBoundOnCost = async (points, path=[], visited=null, overallBest=Infinity) => {
  if (visited === null) {
    // initial call
    path = [points.shift()]
    points = new Set(points);
    visited = new Set();
  }

  const available = setDifference(points, visited);
  const backToStart = [...path, path[0]];
  const cost = pathCost(backToStart);
  

  if (cost > overallBest) {
    // cut this branch
    return [null, null]
  }

  if (available.size === 0) {
    // at the end of a branch
    return [cost, backToStart] 
  }

  let [bestCost, bestPath] = [null, null];

  for (const p of available) {
    visited.add(p)
    path.push(p)

    // recurse
    const [curCost, curPath] = await branchAndBoundOnCost(points, path, visited, overallBest);
    
    
    if (curCost && (!bestCost || curCost < bestCost)) {
      [bestCost, bestPath] = [curCost, curPath];

      if (!overallBest || bestCost < overallBest) {
        overallBest = bestCost
        self.setBestPath(bestPath, bestCost);
      }
    }

    visited.delete(p)
    path.pop();
  }

  return [bestCost, bestPath]
}
```
